# PingPongGame
这是一个类似乒乓球的小游戏，可以双人对战或者人机对战
https://github.com/AlmasB/FXGLGames/tree/master/Pong/src/main/java/com/almasb/fxglgames/pong
在这个项目的基础上修改的.
增加了ai的选择,双人对战.

我现在希望在这里增加选择：增加一个“设置”，进入之后是一个二级菜单，包括声音开关，勾选之后可以开启与关闭声音，音量调节滑槽，可以调整音量大小
---
## 各部分代码功能简要说明
这是一个使用 **FXGL 游戏框架**开发的乒乓球游戏，包含以下主要函数和功能：

### PongApp类

- 继承自 `GameApplication` 类，实现游戏逻辑。对游戏窗口的设置、游戏变量的初始化、玩家输入的处理、UI的创建、物理碰撞的处理、自定义背景的绘制、游戏实体的生成、胜利或失败的判断等。

包含以下主要函数：
1. **`initSettings(GameSettings settings)`**  
   - 配置游戏基本设置，例如窗口大小、标题、版本、是否启用菜单、场景切换动画等。

2. **`initGameVars(Map<String, Object> vars)`**  
   - 初始化游戏变量，包括是否为双人模式、玩家分数、控制按键状态、以及难度等级。

3. **`initInput()`**  
   - 定义玩家输入操作：
     - 玩家1：通过 `W` 和 `S` 键控制球拍移动。
     - 玩家2（双人模式下）：通过方向键 `UP` 和 `DOWN` 控制球拍移动。

4. **`initUI()`**  
   - 创建并绑定玩家分数的显示界面，同时添加分数更新时的动画效果。

5. **`initPhysics()`**  
   - 设置物理碰撞逻辑：
     - 球与墙壁碰撞时更新分数。
     - 球与球拍碰撞时播放音效。

6. **`initCustomBackground()`**  
   - 绘制自定义背景颜色（左右分别为深红色和深蓝色）。

7. **`initGame()`**  
   - 初始化游戏实体和逻辑：
     - 加载音效、设置重力。
     - 生成球和玩家球拍（双人模式下为两个玩家球拍，单人模式下第二个球拍由AI控制）。
     - 设置边界墙。
     - 添加游戏胜利判断逻辑，当一方分数达到10时弹出胜利或失败提示框。

8. **`main(String[] args)`**  
   - 设置系统属性并启动游戏。
---
### PongFactory类

- 继承自 `EntityFactory` 类，实现游戏实体（球和球拍）的生成。

包含以下主要函数：

1. **`newBall(SpawnData data)`**
   - **功能**: 创建游戏中的“球”实体。
   - **主要逻辑**:
     - 添加物理组件：
       - 设置球的初始速度为 `(200, 200)`。
       - 设置球的物理属性，如密度和弹性（完全弹性，`restitution=1.0`）。
     - 监控得分情况：
       - 当任意玩家得分达到 `winningScore - 1` 时，改变粒子效果的颜色。
     - 粒子发射器设置：
       - 设置粒子颜色随游戏状态变化：
         - 游戏未结束时，粒子颜色从 **白色到浅蓝色**。
         - 游戏接近结束时，颜色从 **亮黄色到红色**。
       - 粒子效果包括：
         - 设置粒子的生命周期（0.3 到 1 秒随机）。
         - 粒子大小（5 到 10 像素）。
         - 每帧发射粒子，混合模式为 `BlendMode.SRC_OVER`。
     - 最终构建球实体：
       - 设置类型为 `PongType.ball`。
       - 设置碰撞体积为圆形，半径为 5。
       - 添加组件：物理组件、粒子效果组件和自定义逻辑组件 `BallComponent`。


2. **`newBat(SpawnData data)`**
   - **功能**: 创建游戏中的“球拍”实体。
   - **主要逻辑**:
     - 添加物理组件：
       - 设置球拍为 `KINEMATIC` 类型（不会受物理引擎动态力影响，只能通过代码控制）。
     - 判断是否为玩家控制的球拍：
       - 通过 `isPlayer` 参数判断，并根据 `playerID`（玩家 1 或玩家 2）确定具体逻辑。
     - 球拍位置：
       - 玩家 1 的球拍生成在屏幕左侧，玩家 2 或 AI 的球拍生成在屏幕右侧。
     - 最终构建球拍实体：
       - 设置类型为 `PongType.bat`。
       - 设置碰撞边界盒，形状为白色矩形（宽 10，高 80）。
       - 添加控制逻辑组件：
         - 如果是玩家球拍，根据玩家 ID 添加 `PlayerBatComponent(1)` 或 `PlayerBatComponent(2)`。
         - 如果是 AI 控制的球拍，添加 `EnemyBatComponent`。
       - 设置绘制层级（`zIndex=1`）以控制显示顺序。

---
### BallComponent类
它主要负责控制乒乓球的物理行为，具体包括限制球的速度和检查球是否越界。以下是对每个方法的简要总结：

1. **`onUpdate` 方法**
   - 每帧调用，负责更新球的状态。
   - 调用了两个方法：
     - `limitVelocity()`：限制球的速度，确保球不会以过快的速度运动。
     - `checkOffscreen()`：检查球是否超出屏幕边界，并在超出时将球位置重置到屏幕中央。

2. **`limitVelocity` 方法**
   - **目的**：限制球的速度，防止球以过快的速度运动，从而导致物理引擎中的碰撞或移动行为异常。
   - **X轴速度限制**：
     - 如果球在X轴上的速度小于 `5 * 60`，则将速度设置为 `5 * 60`（方向与原始速度保持一致）。
   - **Y轴速度限制**：
     - 如果球在Y轴上的速度大于 `5 * 60 * 2`，则将速度限制在 `5 * 60 * 2` 以内。

3. **`checkOffscreen` 方法**
   - **目的**：检查球是否超出了屏幕的可视区域。如果球越界，则将其重置到屏幕中心。
   - 使用 `getEntity().getBoundingBoxComponent().isOutside(getGameScene().getViewport().getVisibleArea())` 检查球是否越界。
   - 如果越界，将球的位置设置为屏幕中央（`getAppWidth() / 2d, getAppHeight() / 2d`）。

---
### PlayerBatComponent类
这段代码定义了一个 `PlayerBatComponent` 类，它控制着由玩家操作的乒乓球拍子（在游戏中通常会移动并旋转）。以下是对每个部分的详细解释：

1. **成员变量**：
   - `PhysicsComponent physics`：物理组件，用于处理拍子的物理属性和运动。
   - `int playerID`：玩家的ID，标识是玩家1还是玩家2。
   - `double A = 5000`：拍子加速的常量，控制移动的加速度。
   - `double A_ = -5000`：拍子减速的常量，控制停止时的减速。
   - `double MaxSpeed = 400`：拍子最大速度，防止拍子移动过快。
   - `double a = 0`：当前的加速度，控制拍子的加速或减速。

2. **构造方法**：
   - `public PlayerBatComponent(int i)`：构造方法，接受一个玩家ID `i`，以区分是玩家1还是玩家2。

3. **`onAdded` 方法**：
   - 在 `PlayerBatComponent` 被添加到实体时调用。
   - 设置了与键盘按键的绑定：
     - 如果是玩家1，`key_w` 和 `key_s` 控制拍子上下移动。
     - 如果是玩家2，`key_up` 和 `key_down` 控制拍子上下移动。

   - 这里使用了 `FXGL.getbp("key_x").addListener()` 来监听按键事件。当按键按下或松开时，修改加速度 `a` 的值。

4. **`onUpdate` 方法**：
   - 每帧更新时调用。
   - 调用三个方法：
     - `handleKeyboardControl(tpf)`：处理键盘控制，根据按键控制拍子的速度。
     - `constrainToBounds()`：限制拍子在屏幕内，防止它超出边界。
     - `updateRotation()`：更新拍子的旋转角度，根据其垂直速度进行旋转。

5. **`handleKeyboardControl` 方法**：
   - 处理键盘控制，控制拍子的上下运动。
   - 如果加速度 `a` 不为零，则根据加速度改变拍子的垂直速度 `velocityY`。加速度会影响拍子的速度，使其加速或减速。
   - 使用 `min(max(velocityY, -MaxSpeed), MaxSpeed)` 限制了速度的范围，确保拍子不会以过快的速度移动。
   - 如果 `a == 0`，表示没有按键按下，那么拍子将逐渐减速，最终停止。使用 `A_` 来控制减速。

6. **`constrainToBounds` 方法**：
   - 确保拍子不会超出屏幕的上下边界。
   - 如果拍子的顶部超出了屏幕顶部（`entity.getY() < 0`），则将其位置设置为屏幕顶部。
   - 如果拍子的底部超出了屏幕底部（`entity.getBottomY() > FXGL.getAppHeight()`），则将其位置设置为屏幕底部。

7. **`updateRotation` 方法**：
   - 根据拍子的垂直速度更新拍子的旋转角度。通过 `atan2(physics.getVelocityY(), 1000)` 计算角度并将其转换为度数（使用 `toDegrees()`）。
   - 拍子的旋转角度基于其垂直速度，以模拟拍子在移动时的角度变化。

---
### EnemyBatComponent类
这段代码定义了一个 `EnemyBatComponent` 类，它控制着由电脑（AI）操作的乒乓球拍子。

1. **成员变量**：
   - `PhysicsComponent physics`：物理组件，负责拍子的物理运动。
   - `double A = 3200`：加速度常量，用于控制拍子的移动速度。
   - `double A_ = -5000`：减速度常量，用于控制拍子停下来时的速度变化。
   - `double MaxSpeed = 400`：拍子的最大速度，限制拍子移动过快。
   - `double a = 0`：当前的加速度值，用来控制拍子的加速或减速。
   - `int difficulty`：AI的难度等级，决定AI的行为模式。
   - `Entity ball`：代表游戏中的球，用于判断球的位置并控制拍子的反应。

2. **`onUpdate` 方法**：
   - 每帧更新时调用，根据AI的难度来决定拍子的行为。
   - 根据 `difficulty` 调用不同的AI算法：
     - `AI_0()`: 随机性较高的AI，难度较低。
     - `AI_1()`: 跟随球移动，但加了一些随机性，难度适中。
     - `AI_2()`: 预测球的路径，智能地选择目标位置，难度较高。
     - `AI_3()`: 尝试预测球的轨迹，精度更高，难度较高。
     - `AI_4()`: 最强的AI，尝试完美地预测球的目标位置。
   - 调用 `physics.setVelocityY` 来更新拍子的垂直速度。
   - 确保拍子不超出屏幕的上下边界。
   - 更新拍子的旋转角度，使其根据垂直速度变化。

3. **`predictBallTarget` 方法**：
   - 该方法预测球的落点。
   - 通过球的当前位置和速度，计算球的目标位置。
   - 公式中考虑了球的速度（`vx` 和 `vy`），然后预测球会落到屏幕的哪个位置。
   - 计算出目标位置后，根据球的飞行方向调整目标位置。

4. **移动控制**：
   - AI根据目标位置（`target`）来控制拍子的移动。
   - 如果球在拍子上方，则设置向上的加速度；如果球在下方，则设置向下的加速度。
   - 如果球已经在中间，AI会停顿，或是轻微地调整位置。

5. **出界判定**：
   - 如果拍子越过了屏幕的顶部或底部，AI会将拍子位置修正回屏幕边界内。

6. **旋转更新**：
   - 使用 `atan2` 函数根据拍子的垂直速度来更新拍子的旋转角度。

---
### **`CustomBackgroundView` 类**

- 继承自 `EntityView` 类，实现自定义背景的绘制。
- 绘制了两个矩形，分别填充深红色和深蓝色。

---
### **`PongSceneFactory` 类**

- 继承自 `SceneFactory` 类，实现游戏场景的创建。
- 包含了五个场景：
  - 主菜单（`showMainMenu()`）
  - 难度选择菜单（`showDifficultyMenu()`）
  - 操作说明界面（`showInstructions()`）
  - 开发者信息界面（`showDeveloperInfo()`）
  - 游戏界面（`showGame()`）

---
